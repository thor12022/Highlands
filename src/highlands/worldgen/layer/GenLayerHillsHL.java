package highlands.worldgen.layer;

import org.apache.logging.log4j.Level;

import fabricator77.multiworld.api.biomeregistry.AdvancedBiomeRegistry;
import highlands.Logs;
import highlands.api.HighlandsBiomes;
import net.minecraft.util.WeightedRandom;
import net.minecraft.world.biome.BiomeGenBase;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;
import net.minecraftforge.common.BiomeManager.BiomeEntry;

public class GenLayerHillsHL extends GenLayer
{
    private GenLayer river;
    private BiomeEntry[] islandBiomes;
    private BiomeEntry[] oceanBiomes;

    public GenLayerHillsHL(long par1, GenLayer par3, GenLayer par4)
    {
        super(par1);
        this.parent = par3;
        this.river = par4;
        islandBiomes = AdvancedBiomeRegistry.getBiomesOfType("island");
        oceanBiomes = AdvancedBiomeRegistry.getBiomesOfType("ocean");
    }

    /**
     * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
     * amounts, or biomeList[] indices based on the particular GenLayer subclass.
     */
    @Override
    public int[] getInts(int par1, int par2, int par3, int par4)
    {    	
        int[] aint = this.parent.getInts(par1 - 1, par2 - 1, par3 + 2, par4 + 2);
        int[] aint1 = this.river.getInts(par1 - 1, par2 - 1, par3 + 2, par4 + 2);
        int[] aint2 = IntCache.getIntCache(par3 * par4);

        for (int i1 = 0; i1 < par4; ++i1)
        {
            for (int j1 = 0; j1 < par3; ++j1)
            {
            	// loop start
                this.initChunkSeed((long)(j1 + par1), (long)(i1 + par2));
                int k1 = aint[j1 + 1 + (i1 + 1) * (par3 + 2)];  // parent layer
                int l1 = aint1[j1 + 1 + (i1 + 1) * (par3 + 2)]; // river layer
                boolean flag = (l1 - 2) % 29 == 0; // is biomeID 31 (megaTaiga biome)
                
                //BiomeGenBase biome2 = BiomeGenBase.getBiomeGenArray()[aint1[j1 + i1 * par3]];
                //Logs.log(Level.INFO, "[Highlands] GenLayerRareBiomeHL input=" + biome2.biomeName);

                if (k1 > 255)
                {
                	//Logs.log(Level.INFO, "[Highlands] GenLayerRareBiomeHL k1=" + k1);
                	// k1 = 0;
                }

                if (suitableForSubBiome(k1, l1)) {
                //if (k1 != 0 && l1 >= 2 && l1 == 32 && k1 < 128) {//TODO remove vanilla hardcoded biome ids/assumptions
                	if (AdvancedBiomeRegistry.biomeEntries[k1].subBiomes.length > 0) {
                		aint2[j1 + i1 * par3] = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].subBiomes);
                		//Logs.log(Level.INFO, "placing sub-biome "+BiomeGenBase.getBiome(aint2[j1 + i1 * par3]).biomeName);
                		//aint2[j1 + i1 * par3] = AdvancedBiomeRegistry.biomeEntries[k1].subBiomes[0].biome.biomeID;
                	}
                	else {
                		aint2[j1 + i1 * par3] = k1;
                	}
                }
                else if (this.nextInt(3) != 0 && !flag) // 2 in 3 chance + not megaTaiga
                {
                    aint2[j1 + i1 * par3] = k1;
                }
                else
                {
                    int i2 = k1;
                    int j2;
                    
                    if (AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes.length > 0) {
                    	i2 = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes);
                    	// Logs.log(Level.INFO, "placing hills-biome "+BiomeGenBase.getBiome(i2).biomeName);
                    	//i2 = AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes[0].biome.biomeID;
                    	flag = false;
                    }                    
                    // supports multiple ocean and island biomes
                    else if ( isOceanEdge(aint, j1, i1, par3) && this.nextInt(4) == 0) // was 3
                    {
                    	//islands
                    	i2 = getWeightedBiomeIDFromType(islandBiomes);
                    	
                    	flag = false; //crash fix ?
                    }

                    if (flag && i2 != k1)
                    {
                        if (AdvancedBiomeRegistry.biomeEntries[k1].subBiomes.length > 0) {
                        	i2 = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].subBiomes);
                        	//Logs.log(Level.INFO, "placing sub-biome "+BiomeGenBase.getBiome(i2).biomeName);
                    		// i2 = AdvancedBiomeRegistry.biomeEntries[k1].subBiomes[0].biome.biomeID;
                    	}
                    	else {
                    		i2 = k1;
                    	}
                    }

                    // set output
                    if (i2 == k1) // if subbiome was already here, then leave it.
                    {
                        aint2[j1 + i1 * par3] = k1;
                    }
                    else
                    {
                        j2 = aint[j1 + 1 + (i1 + 1 - 1) * (par3 + 2)];
                        int k2 = aint[j1 + 1 + 1 + (i1 + 1) * (par3 + 2)];
                        int l2 = aint[j1 + 1 - 1 + (i1 + 1) * (par3 + 2)];
                        int i3 = aint[j1 + 1 + (i1 + 1 + 1) * (par3 + 2)];
                        int j3 = 0;

                        if (compareBiomesById(j2, k1))
                        {
                            ++j3;
                        }

                        if (compareBiomesById(k2, k1))
                        {
                            ++j3;
                        }

                        if (compareBiomesById(l2, k1))
                        {
                            ++j3;
                        }

                        if (compareBiomesById(i3, k1))
                        {
                            ++j3;
                        }

                        if (j3 >= 3) // create subbiomes only where surrounding biomes are same parent
                        	         // which means sub biomes cannot be on edges
                        {
                            aint2[j1 + i1 * par3] = i2;
                        }
                        else
                        {
                            aint2[j1 + i1 * par3] = k1;
                        }
                    }
                }
                // loop end
            }
        }

        return aint2;
    }
    
    private boolean isHLOcean(int biomeID){
    	if (HighlandsBiomes.ocean2 != null) {
    		return biomeID == HighlandsBiomes.ocean2.biomeID;
    	}
    	return false;
    }
    
    private int getWeightedBiomeIDFromType(BiomeEntry[] biomeType)
    {
    	int total = (int)this.nextLong(WeightedRandom.getTotalWeight(biomeType));
    	BiomeEntry biomeEntry = (BiomeEntry)WeightedRandom.getItem(biomeType, total);
    	return biomeEntry.biome.biomeID;
    }
    
    private boolean isOceanEdge(int[] aint, int j1, int i1, int par3) {
    	// center biome
    	int k1 = aint[j1 + 1 + (i1 + 1) * (par3 + 2)];
    	// adjacent biomes
    	int a1 = aint[j1 + 1 + (i1 + 1 - 1) * (par3 + 2)];
        int a2 = aint[j1 + 1 + 1 + (i1 + 1) * (par3 + 2)];
        int a3 = aint[j1 + 1 - 1 + (i1 + 1) * (par3 + 2)];
        int a4 = aint[j1 + 1 + (i1 + 1 + 1) * (par3 + 2)];
        // count valid matches with center
        
        int count = 0;
        if (AdvancedBiomeRegistry.biomeEntries[a1] != null && AdvancedBiomeRegistry.biomeEntries[a1].type == "ocean")
        {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a2] != null && AdvancedBiomeRegistry.biomeEntries[a2].type == "ocean")
        {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a3] != null && AdvancedBiomeRegistry.biomeEntries[a3].type == "ocean")
        {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a4] != null && AdvancedBiomeRegistry.biomeEntries[a4].type == "ocean")
        {
            ++count;
        }

        if (count == 4)
        {
        	return true;
        }
        
    	return false;
    }
    
    private boolean suitableForSubBiome (int k1, int l1) {
    	// parent not ocean &&
        // river not plains or ocean &&
        // river is megaTaiga
        // parent not sub biome
        // sub-biomes go here

    	// l1 calculations
    	// 282347 -2 %29
    	// = 282345 %29
    	// = 1
    	// However problems exist with vanilla Jungle Hills/Edges biomes
    	// due to ID numbers matching
    	
    	
    	if (!isOcean(k1) && l1 >= 2 && (l1 - 2) % 29 == 1){	
    		return true;
    	}
    	return false;
    }
    
    private boolean isOcean (int id){
    	for (int i=0; i<oceanBiomes.length; i++) {
    		if (oceanBiomes[i].biome.biomeID == id) {
    			return true;
    		}
    	}
    	return false;
    }
    
    private boolean isSubBiome (int id){
    	if (AdvancedBiomeRegistry.biomeEntries[id].type == "sub") {
    		return true;
    	}
    	return false;
    }
}
